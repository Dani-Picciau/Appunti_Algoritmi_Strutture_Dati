\documentclass[../../main_document/main.tex]{subfiles}
\externaldocument{../../main_document/main}

\begin{document}
    \section{Hashing}
    L'\textbf{hashing} è una \textbf{tecnica alternativa} agli alberi binari di ricerca (capitolo \ref{par:Alberi binari di ricerca (BST)}) o agli array associativi, utilizzata per realizzare i dizionari.

    \vspace{8pt}
    \noindent
    A differenza dell'implementazione tramite alberi, nella quale si riusciva a mantenere la stessa complessità nei casi di \texttt{insert()}, \texttt{lookup()} e \texttt{remove()}, nel caso ideale, la cosa migliore sarebbe quella di \textbf{mantenere una complessità costante} per tutti i tipi di operazioni, che sia inoltre \textbf{inferiore} a quella delle strutture ad albero.\\
    Questa implementazione ideale prende il nome di \textbf{tabelle di hash}.
    \begin{figure}[H]
        \centering
        \vspace{-10pt}  % Riduce lo spazio sopra
        \includegraphics[width=0.95\textwidth]{hashing/img1.png}
        \vspace{-5pt}  % Riduce lo spazio sopra 
    \end{figure}
    \noindent
    Per comprendere il funzionamento delle tabelle hash dobbiamo prendere in considerazione il concetto di \textbf{insieme universo \textit{U}}, ovvero un insieme di tutte le possibili chiavi, la cui grandezza dell'insieme varia arbitrariamente in base ai dati che si vogliono contenere.
    \begin{tcolorbox}[
        colback=yellow!20, 
        colframe=darkgray, 
        title=Idea di base
        ]
        Quello che si vuole fare è memorizzare tutti i dati dell'insieme \textbf{\textit{U}} in un vettore di dimensione ($m$) finita $T[0...m-1]$, ed avere un meccanismo per cui, data una chiave, trovare rapidamente la posizione in cui è memorizzata.
    \end{tcolorbox}
    \noindent
    Le chiavi possono essere delle stringhe, degli oggetti o dei numeri, e il compito delle tabelle hash è quello di trasformarle in un indice all'interno di esse. 
    Per fare ciò viengono utilizzate le \textbf{funzioni hash}.
    \begin{tcolorbox}[
        colback=yellow!20, 
        colframe=darkgray, 
        title=Cos'è una funzione hash?
        ]
        Una \textbf{funzione hash} è una funzione $H$ che mappa ciascuna chiave $k$ appartenente all'insieme universo $U$ ($k \in U$) nell'indice $H(k)$ di un vettore $A$, destinato a contenere la coppia $(k,v)$. Viene definita come $H: U \rightarrow \{0,1,...,m-1\}$.
    \end{tcolorbox}
    \noindent 
    \begin{minipage}[t]{0.560\textwidth}
        \vspace{-25pt}
        \begin{figure}[H]
            \centering
            \addtocounter{figure}{10}
            \caption{Esempio di funzione hash}
            \label{fig:78}
        \end{figure}

        \vspace{-20pt}
        \includegraphics[width=\textwidth]{hashing/img2.png} 
    \end{minipage}%
    \hspace{5pt} % Spazio tra immagine e testo
    \raisebox{2pt}{  
        \begin{minipage}[t]{0.417\textwidth}
            Come si può vedere dall'immagine, viene presa una chiave (in questo caso una stringa) che verrà poi trasformata in qualche modo, tramite la funzione hash (che può essere anche una black box), in un indice.

            \vspace{8pt}
            A questo punto sorge un \textbf{problema}: l'insieme delle chiavi è potenzialmente infinito, ma non si vuole che sia lo stesso anche per la tabella hash, dal momento in cui si potrebbe non disporre
        \end{minipage} 
    }
    \noindent
    dello spazio in memoria necessario per qualunque coppia chiave-valore. Dunque, quello che succede è che avvengono delle \textbf{collisioni}.\\
    Per evitare inutili sprechi di memoria, la dimensione $m$ del vettore non deve essere determinata sulla base dell'intero universo $U$, ma piuttosto in funzione del \textbf{numero di chiavi attese}, ovvero la \textbf{quantità $k$ di elementi} che si prevede saranno \textbf{effettivamente presenti nel dizionario} in un determinato momento.
    \begin{tcolorbox}[
        colback=yellow!20, 
        colframe=darkgray, 
        title=Quando si verifica una collisione?
        ]
        Si verifica una \textbf{collisione} quando due chiavi distinte $k_1 \neq k_2$ vengono mappate dalla funzione hash sulla stessa posizione del vettore, ovvero quando $H(k_1)=H(k_2)$.
    \end{tcolorbox}
    \noindent 
    \begin{minipage}[t]{0.610\textwidth} 
            \includegraphics[width=\textwidth]{hashing/img3.png}
    \end{minipage}%
    \hspace{5pt} % Spazio tra immagine e testo
    \raisebox{169pt}{  
        \begin{minipage}[t]{0.367\textwidth}
            Le collisioni mettono quindi in luce due \textbf{aspetti fondamentali} nella progettazione di una tabella hash:

            \vspace{8pt}
            \begin{itemize}[leftmargin=1em]
                \item La \textbf{scelta della funzione hash} è cruciale, infatti una funzione mal progettata può distribuire le chiavi in modo sbilanciato, causando una concentrazione eccessiva in alcune posizioni del vettore, lasciando quasi del tutto inutilizzate altre.
            \end{itemize}
        \end{minipage} 
    }
    \begin{itemize}[leftmargin=1em]
        \item È essenziale progettare dei \textbf{meccanismi} efficienti per la \textbf{gestione delle collisioni}, poiché anche scegliendo una buona funzione di hash, quando il numero di chiavi possibili supera il numero di posizioni disponibili nella tabella, le collisioni sono inevitabili. Questi meccanismi permettono quindi di \textbf{garantire il corretto funzionamento} delle operazioni di inserimento, ricerca e cancellazione.
    \end{itemize}

    \subsection{Tabelle ad accesso diretto}
    Prima di affrontare il problema delle collisioni, è utile analizzare un caso particolare in cui esse possono essere completamente evitate: le \textbf{tabelle ad accesso diretto}.

    \vspace{8pt} 
    \noindent 
    Questo approccio è applicabile solo quando l'insieme universo $U$ delle chiavi è limitato e di dimensione ridotta, tale da poter essere rappresentato direttamente in memoria senza \textbf{sprechi} eccessivi. Utilizzando un approccio del genere è possibile utilizzare un vettore $A$ della stessa dimensione dell'insieme $U$, quindi $m=|U|$, nel quale ogni chiave $k$ che appartiene all'insieme $U$ viene memorizzata direttamente nella posizione $A[k]$.\\ 
    La funzione hash utilizzata è quindi la \textbf{funzione identità} $ h(k) = k$, in questo caso una \textbf{funzione hash perfetta}, come quella illustrata in figura \ref{fig:78}, che garantisce l'esecuzione delle operazioni di \texttt{insert()}, \texttt{lookup()} e \texttt{remove()} in tempo $O(1)$ nel caso peggiore.\\ 
    In questo modo ogni chiave verrebbe memorizzata in una posizione distinta della tabella.
    
    \vspace{8pt}
    \noindent
    Tuttavia, questo metodo presenta un \textbf{limite fondamentale}:\\
    oltre al fatto che se l'insieme universo $U$ è molto grande, l'approccio non è praticabile, nel caso in cui il numero di chiavi memorizzate nel dizionario sia molto inferiore al massimo disponibile, quindi $m=|U|$, si incorrerebbe in uno \textbf{spreco di meoria} poiché molte posizioni del vettore verrebbero lasciate inutilizzate.\\
    Per questo motivo, le tabelle ad accesso diretto sono utilizzabili solo in contesti specifici e rappresentano principalmente un modello teorico di riferimento per le tabelle hash.

    \subsubsection{Funzioni hash perfette}

\end{document}